# Adding Property Types to Entities

A new feature snuck into Doctrine a while back, and it's *super* cool. Doctrine can now *guess* some configuration about a property via it's type hint. We'll start with the relationship properties, but first, I want to make sure that my database is in sync with my entities. So let's run:

```terminal
symfony console doctrine:schema:update --dump-sql
```

And... yep! My database *does* look like my entities. By the way, looking at all these deprecations down there, we can see there are still some things we need to fix. And we *will* fix them... eventually. We'll run this command again later after we make a bunch of changes, because our goal isn't actually to *change* any of our database configuration - just to simplify it.

Okay, so here's change number one. This `Question` property here holds a `$question` object. I'm going to add `Question` as a type hint, but we have to be careful. It's technically a *nullable* `Question`. Even if this is required in the database, after we instantiate the object, it's possible that the object *will* be instantiated, but the `Question` property will still be null. You'll see me do this with all of my type hints on my entity property types. Truthfully, even if I feel this is technically required in the database, if it's *possible* that it's null in PHP, I'm going to have it be null.

I'm also going to set this to `= null`. That way, if I reference the `Question` property before it's set, instead of getting an error, it will just return null. That change had nothing to do with Doctrine. That's just adding property types. The cool thing is, we don't need this `targetEntity` anymore, because Doctrine's going to be able to figure that out for us. So delete this, and we get to make our configuration a little simpler.

The next entity is in `Question.php`. We're going to do the *same* thing. I'm looking specifically for our relationship fields. This one here is a `OneToMany`, which holds a collection of `$answers`. We're going to add a type hint here in a second, but it's going to be a collection instance. When we do that, it's not going to allow us to get rid of the target entity, because all we're going to be type hinting down here is just `Collection`. I'll skip this one for now and we'll come back. We're just going to focus on the `ManyToOne` relationships for now.

Down here, for owner, let's add `?User` and then `$owner = null`. We can also get rid of that `targetEntity`. And then, over in `QuestionTag`, we'll do the same thing: `?Question $question = null`. Celebrate by getting rid of the `targetEntity`, and then do this *all over again* down here - `?Tag $tag = null`, and then get rid of the `targetEntity` one more time. Whew... done!

This is a nice change that made it easier to write our relationships. To make sure I didn't mess anything up, I'll rerun that `schema:update` command we used earlier and... we're still clean!

All right, now let's go further and add property types to *every* property. This is going to be a little more work, but the result is worth it. Do the same thing here - `?int $id = null` - but because of that, I don't have to have the `type: 'integer'` anymore, so we can delete that. Down here, for `$content`, we'll do the same thing. This is going to be a nullable string, and I'll say `= null`, but in this case, I *do* need to keep `type: 'text'`. The `type: 'text'` means it holds *a lot* of text. If you use the string property type, Doctrine is, by default, going to guess that as the `type: 'string'`. In this case, I want to specify `type: 'text'`, so I'll leave it. By the way, some of you might be wondering why I don't have `string $content = ''` and just remove the question mark. The reason is that this field is required in the database. If I did this and then I had a bug in my code where I *forgot* to set the `$content` property, it would *successfully* save into the database with empty quotes for this `$content` field. By initializing it to null, if I forget to save it, it's actually going to explode when it enters a database. Then I'll be aware of my bug and can fix it instead of it just silently saving the empty quotes. It may be sneaky, but we're *sneakier*.

Okay, let's keep going! A lot of this is going to be busy work, so patience is key. I can get rid of `type: 'string'`, and I can also get rid of the `length` (The default has always been `255`). The `$votes` already looks good, but I can get rid of the `type: 'integer'`. And then, down here on `$status`, this already has the string type, so I'll just remove `type: 'string'`, but I *do* need to keep the `length` if I want it to be shorter.

Moving on to the `Question` entity. This is going to be a lot of the same stuff here. So `?int` on `$id = null`, remove the `type: 'integer'`, update `$name`... and make *that much simpler*. Repeat the same thing for `$slug`. Notice this still uses an annotation from `@Gedmo\Slug`. We're going to fix that in a minute, but I want to finish fixing all of these property types first.

Update `$question`... then update `$askedAt`. This is a `type: 'datetime'`, so that's going to hold a `?\datetime` instance. I'll also initialize that to null. Next, down here, is the `OneToMany` relationship. If you look down here, it's actually initialized in `__construct` to an `ArrayCollection()`. You might think we would put `ArrayCollection` here, but we're actually going to say `Collection`. That's an interface from Doctrine that `ArrayCollection()` implements. We need to use `Collection` here because, when we query for a question in the database, and then fetch the `$answers` property, it's actually a different object called a `PersistentCollection()`. So this property could *actually* be a `Collection`, an `ArrayCollection()`, *or* a `PersistentCollection()`, but in all cases, it's going to implement this `Collection` interface. This *doesn't* need to be nullable because it's initialized *inside* the constructor. I'll do the same thing right below for `$questionTags`.

All right, we're making good progress! I'll go through `QuestionTag` and speed through some of these repetitive changes. Perfect!

Down here, on `$taggedAt`, this is a `datetime_immutable`, so I'm going to put `\DateTimeImmutable` here. Notice that I did *not* make this nullable and I'm not initializing that to null. That's simply because we are setting this in the constructor, so I'm guaranteed to have a `\DateTimeImmutable` instance. It will never be null and it doesn't need to be initialized to null.

Over in `Tag`, we'll make the easy changes quickly. And actually, I forgot to remove that `type: 'integer'` in `QuestionTag`. It wouldn't hurt anything, but we don't need it anymore. Perfect! I'll also remove this `type: 'datetime_immutable`.

Back in `Tag`, let's keep going. We'll set the `$name` property and simplify its config. And then one more class: `User`. We'll set the property type on `?int` and update the `$email` property. Down here, for the hashed `$password`, we can remove `type: 'string'`. I'm also going to remove the PHP Doc on this, because we can already guess that it's a string or null from the property type. I'll do the same thing down here for my `$plainPassword`, which should actually be a string or null. And then I have a number of other normal fields. I'll update `$firstName`, add `Collection` for `$questions`, and we can remove the type of boolean for `$isVerified`.

Okay! That is *so* much better! It's a little tricky, but it will be much easier going forward, knowing that we didn't mess anything up. This is what's so great about that command. If we run `doctrine:schema:update` again... it's clean! If we had messed something up or accidentally changed our config, this would show us some queries we would need to run to update our database. That would signal that something was wrong with the property, and urge us to take a closer look.

There was one last annotation that we needed to fix, and this one we're just going to fix by hand. It's in the `Question` entity above the `$slug` field, and it comes from the Doctrine extensions library. It's really simple! As long as you have Doctrine Extensions 3.6 or higher, you can use this as an attribute - so `@Gedmo\Slug` - and then we'll say `fields`. And then we need to set this to an array. The cool thing about PHP attributes is it's just PHP code, so an array is a PHP array, and inside, we need `'name'`. I use single quotes, just like PHP. And we are *good*! Whew...

All right, team. We just took our code base a *huge* step forward. Next, let's dial in on these remaining deprecations and work on squashing them so we're ready for Symfony 6. We're going to start with the elephant in the room, which is converting to the new security system. But don't worry! It's easier than you might think!
